#include <math.h>
#include <stdio.h>
#include <MKL25Z4.h>
#include <stdlib.h>

#define RS 0x04     /* PTA2 mask */ 
#define RW 0x10     /* PTA4 mask */ 
#define EN 0x20     /* PTA5 mask */

void Delay(volatile unsigned int time_del);
void keypad_init(void);
uint32_t keypad_getkey(void);
void print_lcd(unsigned char *data_two);
void clear_lcd(void);
void LCD_command(unsigned char command);
void LCD_data(unsigned char data);
void LCD_init(void);
void LCD_ready(void);
int expo_(unsigned int num_);

int main(void)
{ 
	uint32_t key;
	int a, num1=0, num2=0,num3=0,num4=0,num5=0,num6=0,num7=0,num8=0;
	int section_1 = 1;
	int section_2 = 1;
	int section_3 = 0;
	int entries_[6] ; 
	int finishh__ = 1;
	char sel_op[] = "Select Op.(*:Int , #:Der)";
	int range__ = 7;
	int count = 0;
	int int_1;
	char char_2[] = "Eray G.";
	char string__[] = {'#','*'};
	char string__1[2];
	char button_table[]= {'1','2','3','+','4','5','6','B','7','8','9','C','*','0','#','D'};
	LCD_init();
	LCD_command(0x80);      
	print_lcd("EE212");
	LCD_command(0xC0);  
	print_lcd(char_2);
		keypad_init();
    while(keypad_getkey() == 0)
    {
		}
    LCD_command(0x01); 
		
		// user input for the polynomials
		while(section_1)
		{
		Delay(300000);	
		key=keypad_getkey();
			if(key != 0)
			{
				if(count != 6 ){
					if(button_table[key-1] != string__[0]){
						string__1[0]= button_table[key-1];
						a = (int)(button_table[key-1])-'0';
						entries_[count] = a;
					 LCD_data(button_table[key-1]);
						count++;
					}
				}
				else if(button_table[key-1] == string__[0]){
					section_1 = 0;
				}
				Delay(300000);
				key =0;
		}
	}
	LCD_command(0x01); // clear lcd
	LCD_command(0x80); // move to first line
	print_lcd(sel_op); //user input is done
	LCD_command(0xC0);	// move to second line
	LCD_data(':');
 while(keypad_getkey() == 0)
    {
		}
	// deciding derivation or integral
		while(section_2){
		Delay(300000);	
		key=keypad_getkey();
		
		switch(button_table[key-1]){
			case '#':
				print_lcd("Derivation(#)");
			section_2 =0;
			section_3 = 1;
				break;
			case '*':
				print_lcd("Integral(*)");
			section_2 = 0;
				break;
			default:
				Delay(300000);
				key =0;
		}
		Delay(900000);
				key =0;
	}
		
	if(section_3 == 1){
	
	// Derivation part
	LCD_command(0x01); // clear lcd
	LCD_command(0x80);
	print_lcd("diff. pt:");
	LCD_command(0xC0);	// move to second line
	while(keypad_getkey() == 0)
    {
		}
		while(finishh__){
			Delay(300000);	
		key=keypad_getkey();
			if(key != 0)
			{
				if(button_table[key-1] != string__[0]){
					num1 =  10*num1 + (int)(button_table[key-1]) - '0';
					LCD_data(button_table[key-1]);
				}
				else{
					Delay(300000);
				key =0;
					finishh__ = 0;
				}
		}
			Delay(300000);
				key =0;
}
	
	clear_lcd();

		 num2 = 5 * pow(num1, 4) * entries_[5] + 4 * pow(num1, 3) * entries_[4] + 3 * pow(num1, 2) * entries_[3] +
             2 * num1 * entries_[2] + entries_[1];


	 print_lcd("Result:");
LCD_command(0xC0);	// move to second line
   for(int_1 =11; int_1 > 0; int_1--){
      num3 = expo_(int_1);
			num4 = num2 / num3;
			num2 = num2 % num3;
		 if(num4 == 0){
			 if(num5 != 0){
			 LCD_data((char)(num4 + '0'));
			 }
		 }
		 else{
			 LCD_data((char)(num4 + '0'));
			 num5++;
		 }
			
	 }
	 LCD_data((char)(num2 + '0'));
	
	}
	else {
		// Integration
	LCD_command(0x01); // clear lcd
	LCD_command(0x80);
	print_lcd("Press to launch:");
	
	while(keypad_getkey() == 0)
    {
		}
		while(finishh__){
			Delay(300000);	
		key=keypad_getkey();
			if(key != 0)
			{
				if(button_table[key-1] != string__[0]){
					num1 =  10*num1 + (int)(button_table[key-1]) - '0';
					LCD_data(button_table[key-1]);
				}
				else{
					Delay(300000);
				key =0;
					finishh__ = 0;
				}

		}
			Delay(300000);
				key =0;
}
		
		LCD_command(0xC0);	// move to second line
		finishh__ = 1;
    print_lcd("Finish:");
		while(keypad_getkey() == 0)
    {
		}
		while(finishh__){
			Delay(300000);	
		key=keypad_getkey();
			if(key != 0)
			{
				if(button_table[key-1] != string__[0]){
					num2 =  10*num2 + (int)(button_table[key-1]) - '0';
					LCD_data(button_table[key-1]);
				}
				else{
					Delay(300000);
				key =0;
					finishh__ = 0;
				}

		}
			Delay(300000);
				key =0;
   }
		clear_lcd();
	 
	 if(num1 > 7 || num2 > 7){
		  
	 num6 = pow(num1, 6) * entries_[5] / 6 + pow(num1, 5) * entries_[4] / 5 + pow(num1, 4) * entries_[3] / 4 +
                 pow(num1, 3) * entries_[2] / 3 + pow(num1, 2) * entries_[1] / 2 + num1 * entries_[0];

            num7 = pow(num2, 6) * entries_[5] / 6 + pow(num2, 5) * entries_[4] / 5 + pow(num2, 4) * entries_[3] / 4 +
                 pow(num2, 3) * entries_[2] / 3 + pow(num2, 2) * entries_[1] / 2 + num2 * entries_[0];

			 num8 = 1;
		 
	 }
	 //Just in case,pow function is not used
	 else{
		  
		 num7 = 1000*num2*num2*num2*num2*num2*num2*entries_[5]/6;
	 num7 += 1000*num2*num2*num2*num2*num2*entries_[4]/5;
	 num7 += 1000*num2*num2*num2*num2*entries_[3]/4;
	 num7 += 1000*num2*num2*num2*entries_[2]/3;
	 num7 += 1000*num2*num2*entries_[1]/2;
	 num7 += 1000*num2*entries_[0];
		 
		 num6 = 1000*num1*num1*num1*num1*num1*num1*entries_[5]/6;
	 num6 += 1000*num1*num1*num1*num1*num1*entries_[4]/5;
	 num6 += 1000*num1*num1*num1*num1*entries_[3]/4;
	 num6 += 1000*num1*num1*num1*entries_[2]/3;
	 num6 += 1000*num1*num1*entries_[1]/2;
	 num6 += 1000*num1*entries_[0];
	 
	 }
		 
	 print_lcd("Result:");
	 LCD_command(0xC0);	// move to second line
	 if (num2 >= num1){
	 num7 = num7 - num6;
	 }
	 else{
		 	 num7 = num6 - num7;
		 LCD_data('-');
	 }
	 if(num7 != 0){
	 for(int_1 = 9; int_1 > 0; int_1--){
      num3 = expo_(int_1);
			num4 = num7 / num3;
			num7 = num7 % num3;
		 if(num4 == 0){
			 if(num5 != 0){
			 LCD_data((char)(num4 + '0'));
			 }
		 }
		 else{
			 LCD_data((char)(num4 + '0'));
			 num5++;
		 }
			if(int_1 == 3 && num8 == 0){
				LCD_data('.');
			}
	 }
 
	LCD_data((char)(num7+ '0'));
	 if(num8 == 1){
		print_lcd(".000");
	 }
 }
	 else{
	 print_lcd("0.000");
	 }
	}
}


int expo_(unsigned int num_){
	int  pow_1 = 1;
	int i;
	for(i=0;i < num_;++i)
			  {
				  pow_1 =  pow_1*10;
			  }
			return  pow_1;
				
}

void clear_lcd(void)
{	
	int i;
	LCD_command(0x80); //Start from the 1st line
	for(i = 16; i > 0; i--)
	{
			LCD_data(' '); //Clear the 1st line
	}
	LCD_command(0xC0); //Go to the 2nd line
	for(i = 16; i > 0; i--)
	{
			LCD_data(' '); //Clear the 2nd line
	}
	LCD_command(0x80);
}

void print_lcd(unsigned char *data_two){
	int i = 0 ;
	//Continue until a NULL char comes
	while(data_two[i] != 0x00)
	{
		LCD_data(data_two[i]);
		i++;
	}	
}

void LCD_init(void)
{
    SIM->SCGC5 |= 0x1000;       /* enable clock to Port D */ 
    PORTD->PCR[0] = 0x100;      /* mint_1e PTD0 pin as GPIO */
    PORTD->PCR[1] = 0x100;      /* mint_1e PTD1 pin as GPIO */
    PORTD->PCR[2] = 0x100;      /* mint_1e PTD2 pin as GPIO */
    PORTD->PCR[3] = 0x100;      /* mint_1e PTD3 pin as GPIO */
    PORTD->PCR[4] = 0x100;      /* mint_1e PTD4 pin as GPIO */
    PORTD->PCR[5] = 0x100;      /* mint_1e PTD5 pin as GPIO */
    PORTD->PCR[6] = 0x100;      /* mint_1e PTD6 pin as GPIO */
    PORTD->PCR[7] = 0x100;      /* mint_1e PTD7 pin as GPIO */
    PTD->PDDR = 0xFF;           /* mint_1e PTD7-0 as output pins */
    
    SIM->SCGC5 |= 0x0200;       /* enable clock to Port A */ 
    PORTA->PCR[2] = 0x100;      /* mint_1e PTA2 pin as GPIO */
    PORTA->PCR[4] = 0x100;      /* mint_1e PTA4 pin as GPIO */
    PORTA->PCR[5] = 0x100;      /* mint_1e PTA5 pin as GPIO */
    PTA->PDDR |= 0x34;          /* mint_1e PTA5, 4, 2 as output pins */
    
    LCD_command(0x38);      /* set 8-bit data, 2-line, 5x7 font */
    LCD_command(0x01);      /* clear screen, move cursor to home */
    LCD_command(0x0F);      /* turn on display, cursor blinking */
}

/* This function waits until LCD controller is ready to
 * accept a new command/data before returns.
 */
void LCD_ready(void)
{
    uint32_t status;
    
    PTD->PDDR = 0x00;          /* PortD input */
    PTA->PCOR = RS;         /* RS = 0 for status */
    PTA->PSOR = RW;         /* R/W = 1, LCD output */
    
    do {    /* stay in the loop until it is not busy */
			  PTA->PCOR = EN;
			  Delay(500);
        PTA->PSOR = EN;     /* raise E */
        Delay(500);
        status = PTD->PDIR; /* read status register */
        PTA->PCOR = EN;
        Delay(500);			/* clear E */
    } while (status & 0x80UL);    /* check busy bit */
    
    PTA->PCOR = RW;         /* R/W = 0, LCD input */
    PTD->PDDR = 0xFF;       /* PortD output */
}

void LCD_command(unsigned char command)
{
    LCD_ready();			/* wait until LCD is ready */
    PTA->PCOR = RS | RW;    /* RS = 0, R/W = 0 */
    PTD->PDOR = command;
    PTA->PSOR = EN;         /* pulse E */
    Delay(500);
    PTA->PCOR = EN;
}

void LCD_data(unsigned char data)
{
    LCD_ready();			/* wait until LCD is ready */
    PTA->PSOR = RS;         /* RS = 1, R/W = 0 */
    PTA->PCOR = RW;
    PTD->PDOR = data;
    PTA->PSOR = EN;         /* pulse E */
    Delay(500);
    PTA->PCOR = EN;
}

/* Delay n milliseconds
 * The CPU core clock is set to MCGFLLCLK at 41.94 MHz in SystemInit().
 */

/* delay n microseconds
 * The CPU core clock is set to MCGFLLCLK at 41.94 MHz in SystemInit().
 */


void Delay(volatile unsigned int time_del) {
  while (time_del--) 
		{
  }
}


void keypad_init(void)
{
    SIM->SCGC5 |= 0x0800;       /* enable clock to Port C */ 
    PORTC->PCR[0] = 0x103;      /* mint_1e PTC0 pin as GPIO and enable pullup*/
    PORTC->PCR[1] = 0x103;      /* mint_1e PTC1 pin as GPIO and enable pullup*/
    PORTC->PCR[2] = 0x103;      /* mint_1e PTC2 pin as GPIO and enable pullup*/
    PORTC->PCR[3] = 0x103;      /* mint_1e PTC3 pin as GPIO and enable pullup*/
    PORTC->PCR[4] = 0x103;      /* mint_1e PTC4 pin as GPIO and enable pullup*/
    PORTC->PCR[5] = 0x103;      /* mint_1e PTC5 pin as GPIO and enable pullup*/
    PORTC->PCR[6] = 0x103;      /* mint_1e PTC6 pin as GPIO and enable pullup*/
    PORTC->PCR[7] = 0x103;      /* mint_1e PTC7 pin as GPIO and enable pullup*/
    PTC->PDDR = 0x00;         /* mint_1e PTC7-0 as input pins */
}




uint32_t keypad_getkey(void)
{
    uint32_t row, col;
    const char row_select[] = {0x01, 0x02, 0x04, 0x08}; /* one row is active */

    /* check to see any key pressed */
    PTC->PDDR |= 0x0F;          /* rows output */
    PTC->PCOR = 0x0F;               /* ground rows */
    Delay(500);                 /* wait for signal return */
    col =  PTC->PDIR & 0xF0UL;     /* read all columns */
    PTC->PDDR = 0;              /*  rows input */
    if (col == 0xF0UL)
        return 0;               /* no key pressed */

    /* If a key is pressed, it gets here to find out which key.
     * It activates one row at a time and read the input to see
     * which column is active. */
    for (row = 0; row < 4; row++)
    {
        PTC->PDDR = 0;                  /* disable all rows */
        PTC->PDDR |= row_select[row];   /* enable one row */
        PTC->PCOR = row_select[row];    /* drive the active row low */
        Delay(500);                     /* wait for signal to settle */
        col = PTC->PDIR & 0xF0UL;         /* read all columns */
        if (col != 0xF0UL) break;         /* if one of the input is low, some key is pressed. */
    }
    PTC->PDDR = 0;                      /* disable all rows */
    if (row == 4) 
        return 0;                       /* if we get here, no key is pressed */
 
    /* gets here when one of the rows has key pressed, check which column it is */
    if (col == 0xE0UL) return row * 4 + 1;    /* key in column 0 */
    if (col == 0xD0UL) return row * 4 + 2;    /* key in column 1 */
    if (col == 0xB0UL) return row * 4 + 3;    /* key in column 2 */
    if (col == 0x70UL) return row * 4 + 4;    /* key in column 3 */

    return 0;   /* just to be safe */
}